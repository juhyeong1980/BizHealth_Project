<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>3D 입체 검진예약 데이터 흐름도 - Interactive</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin="anonymous"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin="anonymous"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Pretendard', sans-serif;
            background-color: #ffffff;
            color: #1e293b;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #labels-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none;
            overflow: hidden;
        }

        .floating-label {
            position: absolute;
            transform: translate(-50%, -50%);
            text-align: center;
            transition: z-index 0s, transform 0.2s, opacity 0.3s;
            pointer-events: auto;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // 아이콘 컴포넌트
        const Icons = {
            User: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" /><circle cx="12" cy="7" r="4" /></svg>,
            Phone: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z" /></svg>,
            Laptop: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M20 16V7a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v9m16 0H4m16 0 1.28 2.55a1 1 0 0 1-.9 1.45H3.62a1 1 0 0 1-.9-1.45L4 16" /></svg>,
            Database: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><ellipse cx="12" cy="5" rx="9" ry="3" /><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3" /><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5" /></svg>,
            Activity: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2" /></svg>,
            CheckCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></svg>,
            Server: () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><rect width="20" height="8" x="2" y="2" rx="2" ry="2" /><rect width="20" height="8" x="2" y="14" rx="2" ry="2" /><line x1="6" x2="6.01" y1="6" y2="6" /><line x1="6" x2="6.01" y1="18" y2="18" /></svg>,
            ArrowLeft: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="m15 18-6-6 6-6" /></svg>,
            ArrowRight: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="m9 18 6-6-6-6" /></svg>
        };

        const Flowchart3D = () => {
            const containerRef = useRef(null);
            const [nodePositions, setNodePositions] = useState([]);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const requestRef = useRef(null);
            const [hoveredNode, setHoveredNode] = useState(null);

            const hoveredNodeRef = useRef(null);

            useEffect(() => {
                hoveredNodeRef.current = hoveredNode;
            }, [hoveredNode]);

            const nodesData = [
                { id: 'sales', label: '영업', subLabel: '사전입력', icon: 'User', x: -5, y: 0, z: 0, color: 0x60a5fa, shape: 'box' },
                { id: 'customer_direct', label: '고객', subLabel: '직접입력', icon: 'Laptop', x: -3, y: 3, z: -1.5, color: 0x34d399, shape: 'box' },
                { id: 'support', label: 'CS파트', subLabel: '상담', icon: 'Phone', x: -3, y: -3, z: 1.5, color: 0xfb923c, shape: 'box' },
                { id: 'platform', label: '예약플랫폼', subLabel: 'Main Hub', icon: 'Database', x: 0, y: 0, z: 0, color: 0x4f46e5, shape: 'sphere' },
                { id: 'saerom', label: '검진프로그램', subLabel: '새롬', icon: 'Server', x: 3, y: 2, z: -2, color: 0x94a3b8, shape: 'box' },
                { id: 'uzens', label: '유젠스', subLabel: '외주', icon: 'Activity', x: 3, y: -2, z: 2, color: 0x94a3b8, shape: 'box' },
                { id: 'customer_end', label: '고객', subLabel: '결과수신', icon: 'CheckCircle', x: 6, y: 0, z: 0, color: 0x2dd4bf, shape: 'box' },
            ];

            const edgesData = [
                { from: 'sales', to: 'platform', color: 0x60a5fa },
                { from: 'customer_direct', to: 'platform', color: 0x34d399 },
                { from: 'support', to: 'platform', color: 0xfb923c },
                { from: 'platform', to: 'saerom', color: 0x4f46e5 },
                { from: 'platform', to: 'uzens', color: 0x4f46e5 },
                { from: 'saerom', to: 'uzens', color: 0x94a3b8 },
                { from: 'saerom', to: 'customer_end', color: 0x94a3b8 },
                { from: 'uzens', to: 'customer_end', color: 0x94a3b8 },
            ];

            useEffect(() => {
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.fog = new THREE.FogExp2(0xffffff, 0.02);

                const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });

                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                containerRef.current.appendChild(renderer.domElement);

                sceneRef.current = scene;
                cameraRef.current = camera;
                rendererRef.current = renderer;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7);
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                dirLight.shadow.camera.near = 0.5;
                dirLight.shadow.camera.far = 50;
                dirLight.shadow.radius = 4;
                scene.add(dirLight);

                const pointLight = new THREE.PointLight(0x6366f1, 1.5, 20);
                pointLight.position.set(0, 3, 0);
                scene.add(pointLight);

                const objects = {};
                const droplets = [];
                const lineMeshes = [];

                const boxGeometry = new THREE.BoxGeometry(1.3, 1.3, 1.3);
                const sphereGeometry = new THREE.SphereGeometry(1.0, 48, 48);

                const originalColors = {};

                nodesData.forEach(node => {
                    let mesh;
                    const material = new THREE.MeshPhysicalMaterial({
                        color: node.color,
                        metalness: 0.1,
                        roughness: 0.2,
                        clearcoat: 0.5,
                        clearcoatRoughness: 0.1,
                        emissive: 0x000000,
                        emissiveIntensity: 0,
                        transparent: true,
                        opacity: 1.0
                    });

                    if (node.shape === 'sphere') {
                        mesh = new THREE.Mesh(sphereGeometry, material);
                    } else {
                        mesh = new THREE.Mesh(boxGeometry, material);
                    }

                    mesh.position.set(node.x, node.y, node.z);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData = {
                        id: node.id,
                        originalY: node.y,
                        animPhase: Math.random() * Math.PI * 2,
                        fillLevel: 0,
                        originalColorHex: node.color,
                        currentScale: 1.0
                    };

                    originalColors[node.id] = new THREE.Color(node.color);

                    scene.add(mesh);
                    objects[node.id] = mesh;
                });

                const dropletGeometry = new THREE.SphereGeometry(0.08, 16, 16);
                const dropletMaterial = new THREE.MeshBasicMaterial({
                    color: 0x3b82f6,
                    transparent: true,
                    opacity: 1.0
                });

                edgesData.forEach(edge => {
                    const startObj = objects[edge.from];
                    const endObj = objects[edge.to];
                    const start = startObj.position;
                    const end = endObj.position;

                    const points = [start, end];
                    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                    const lineMaterial = new THREE.LineDashedMaterial({
                        color: 0x94a3b8,
                        linewidth: 1,
                        scale: 1,
                        dashSize: 0.2,
                        gapSize: 0.2,
                        transparent: true,
                        opacity: 1.0
                    });
                    const line = new THREE.Line(lineGeometry, lineMaterial);
                    line.computeLineDistances();
                    line.userData = { from: edge.from, to: edge.to };
                    scene.add(line);
                    lineMeshes.push(line);

                    const distance = start.distanceTo(end);
                    const dropletCount = Math.floor(distance / 1.5) || 1;

                    for (let i = 0; i < dropletCount; i++) {
                        const droplet = new THREE.Mesh(dropletGeometry, dropletMaterial.clone());
                        scene.add(droplet);
                        droplets.push({
                            mesh: droplet,
                            start: start,
                            end: end,
                            progress: i / dropletCount,
                            speed: 0.5 / distance,
                            fromId: edge.from,
                            toId: edge.to
                        });
                    }
                });

                const gridHelper = new THREE.GridHelper(30, 30, 0xe2e8f0, 0xf1f5f9);
                gridHelper.position.y = -4;
                scene.add(gridHelper);

                const clock = new THREE.Clock();
                const camState = { phi: 1.0, theta: 0.5, radius: 14 };

                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };

                const onMouseDown = (e) => {
                    if (e.target.closest('.floating-label') || e.target.closest('.bottom-nav-btn')) return;
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                };

                const onMouseMove = (e) => {
                    if (isDragging) {
                        const deltaMove = {
                            x: e.clientX - previousMousePosition.x,
                            y: e.clientY - previousMousePosition.y
                        };
                        camState.theta -= deltaMove.x * 0.005;
                        camState.phi -= deltaMove.y * 0.005;
                        camState.phi = Math.max(0.1, Math.min(Math.PI - 0.1, camState.phi));
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                };

                const onMouseUp = () => isDragging = false;
                const onWheel = (e) => {
                    camState.radius += e.deltaY * 0.01;
                    camState.radius = Math.max(8, Math.min(25, camState.radius));
                };

                window.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
                window.addEventListener('wheel', onWheel);

                const activeFillColor = new THREE.Color(0xf43f5e);

                const renderLoop = () => {
                    requestRef.current = requestAnimationFrame(renderLoop);
                    const time = clock.getElapsedTime();

                    const currentHoveredId = hoveredNodeRef.current;

                    camera.position.x = camState.radius * Math.sin(camState.phi) * Math.sin(camState.theta);
                    camera.position.y = camState.radius * Math.cos(camState.phi);
                    camera.position.z = camState.radius * Math.sin(camState.phi) * Math.cos(camState.theta);
                    camera.lookAt(0, 0, 0);

                    const activeTargets = [];
                    let activeNodeIds = [];

                    if (currentHoveredId) {
                        edgesData.forEach(e => {
                            if (e.from === currentHoveredId) {
                                activeTargets.push(e.to);
                            }
                        });
                        activeNodeIds = [currentHoveredId, ...activeTargets];
                    }

                    Object.keys(objects).forEach(key => {
                        const obj = objects[key];

                        obj.position.y = obj.userData.originalY + Math.sin(time * 1.5 + obj.userData.animPhase) * 0.15;
                        obj.rotation.y = Math.sin(time * 0.5 + obj.userData.animPhase) * 0.1;
                        if (key === 'platform') obj.rotation.y += 0.01;

                        const isTarget = activeTargets.includes(key);
                        const isHovered = key === currentHoveredId;
                        const isActive = currentHoveredId ? activeNodeIds.includes(key) : true;

                        let targetScale = 1.0;
                        if (currentHoveredId) {
                            if (isActive) targetScale = 1.3;
                            else targetScale = 1.0;
                        }

                        obj.userData.currentScale += (targetScale - obj.userData.currentScale) * 0.1;
                        obj.scale.setScalar(obj.userData.currentScale);

                        let targetOpacity = 1.0;
                        if (currentHoveredId && !isActive) {
                            targetOpacity = 0.2;
                        }

                        obj.material.opacity += (targetOpacity - obj.material.opacity) * 0.1;

                        const targetFillLevel = isTarget ? 1.0 : 0.0;
                        const lerpFactor = 0.05;
                        obj.userData.fillLevel += (targetFillLevel - obj.userData.fillLevel) * lerpFactor;

                        const fillRatio = obj.userData.fillLevel;
                        const baseColor = originalColors[key];

                        obj.material.color.lerpColors(baseColor, activeFillColor, fillRatio);
                        obj.material.emissive.copy(activeFillColor);
                        obj.material.emissiveIntensity = fillRatio * 0.6;
                    });

                    lineMeshes.forEach(line => {
                        const isRelated = currentHoveredId ? (line.userData.from === currentHoveredId) : true;
                        const targetOpacity = isRelated ? 1.0 : 0.1;
                        line.material.opacity += (targetOpacity - line.material.opacity) * 0.1;
                    });

                    droplets.forEach(d => {
                        const isHighSpeed = currentHoveredId && d.fromId === currentHoveredId;
                        const speedMultiplier = isHighSpeed ? 3.0 : 1.0;

                        const isRelated = currentHoveredId ? (d.fromId === currentHoveredId) : true;
                        const targetOpacity = isRelated ? 1.0 : 0.1;
                        d.mesh.material.opacity += (targetOpacity - d.mesh.material.opacity) * 0.1;

                        d.progress += d.speed * 0.03 * speedMultiplier;
                        if (d.progress > 1) d.progress = 0;
                        d.mesh.position.lerpVectors(d.start, d.end, d.progress);

                        if (isHighSpeed) {
                            d.mesh.material.color.setHex(0x60a5fa);
                        } else {
                            d.mesh.material.color.setHex(0x3b82f6);
                        }
                    });

                    const positions = nodesData.map(node => {
                        const obj = objects[node.id];
                        const vector = obj.position.clone();
                        vector.y += 1.4 * obj.userData.currentScale;
                        vector.project(camera);

                        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
                        const isVisible = vector.z < 1;

                        const isActive = currentHoveredId ? activeNodeIds.includes(node.id) : true;
                        const opacity = isActive ? 1.0 : 0.2;

                        return { id: node.id, x, y, visible: isVisible, zIndex: isVisible ? Math.floor((1 - vector.z) * 1000) : 0, opacity };
                    });

                    setNodePositions(positions);
                    renderer.render(scene, camera);
                };

                renderLoop();

                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    window.removeEventListener('resize', handleResize);
                    window.removeEventListener('mousedown', onMouseDown);
                    window.removeEventListener('mousemove', onMouseMove);
                    window.removeEventListener('mouseup', onMouseUp);
                    window.removeEventListener('wheel', onWheel);
                    cancelAnimationFrame(requestRef.current);
                    if (containerRef.current) containerRef.current.innerHTML = '';
                };
            }, []);

            const getNodeData = (id) => nodesData.find(n => n.id === id);

            return (
                <div className="relative w-full h-full bg-white text-slate-800">
                    <div ref={containerRef} id="canvas-container" />

                    <div id="labels-container">
                        {nodePositions.map(pos => {
                            const node = getNodeData(pos.id);
                            if (!pos.visible) return null;
                            const isHub = node.id === 'platform';

                            return (
                                <div
                                    key={node.id}
                                    className={`floating-label flex flex-col items-center justify-center p-3 rounded-xl shadow-xl border-2 pointer-events-auto transition-colors duration-200
                    bg-white border-slate-200 hover:border-indigo-500 hover:bg-indigo-50 hover:shadow-2xl
                  `}
                                    style={{
                                        left: pos.x,
                                        top: pos.y,
                                        zIndex: pos.zIndex,
                                        opacity: pos.opacity,
                                    }}
                                    onMouseEnter={() => setHoveredNode(node.id)}
                                    onMouseLeave={() => setHoveredNode(null)}
                                >
                                    <div className={`mb-1 p-1.5 rounded-full ${isHub ? 'bg-indigo-50 text-indigo-600' : 'bg-slate-50 text-slate-500'}`}>
                                        {Icons[node.icon] && Icons[node.icon]()}
                                    </div>
                                    <div className="text-sm font-extrabold text-slate-800 whitespace-nowrap">{node.label}</div>
                                    <div className="text-xs text-slate-500 font-bold">{node.subLabel}</div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Bottom Navigation Arrows */}
                    <div className="fixed bottom-8 left-1/2 transform -translate-x-1/2 z-50 flex gap-12 bottom-nav-btn">
                        {/* Prev Button */}
                        <div className="flex flex-col items-center gap-2 cursor-pointer group" onClick={() => alert('이전 페이지로 이동합니다.')}>
                            <div className="w-12 h-12 bg-white rounded-full shadow-lg border border-slate-200 flex items-center justify-center text-slate-400 group-hover:text-indigo-600 group-hover:border-indigo-300 group-hover:shadow-indigo-100 transition-all duration-300 hover:-translate-x-1">
                                <Icons.ArrowLeft />
                            </div>
                            <span className="text-xs text-slate-400 opacity-0 group-hover:opacity-100 transition-opacity duration-300 font-medium bg-white/80 px-2 py-1 rounded-full backdrop-blur-sm shadow-sm">이전</span>
                        </div>

                        {/* Next Button */}
                        <div className="flex flex-col items-center gap-2 cursor-pointer group" onClick={() => alert('다음 페이지로 이동합니다.')}>
                            <div className="w-12 h-12 bg-white rounded-full shadow-lg border border-slate-200 flex items-center justify-center text-slate-400 group-hover:text-indigo-600 group-hover:border-indigo-300 group-hover:shadow-indigo-100 transition-all duration-300 hover:translate-x-1">
                                <Icons.ArrowRight />
                            </div>
                            <span className="text-xs text-slate-400 opacity-0 group-hover:opacity-100 transition-opacity duration-300 font-medium bg-white/80 px-2 py-1 rounded-full backdrop-blur-sm shadow-sm">다음</span>
                        </div>
                    </div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Flowchart3D />);
    </script>
</body>

</html>